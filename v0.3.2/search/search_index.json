{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Zeto","text":"<p>Zeto is a collection of privacy-preserving token implementations on EVM, using Zero Knowledge Proof to enforce a varieties of tokenonmic policies, suited for use in enterprise use cases such as CBDCs, tokenized deposits, security trading that meet regulatory requirements such as KYC.</p> <p></p> <p>Zeto tokens give enterprises control of sensitive information without compromising transparency or scalability.</p> <p>The Zeto project is Apache 2.0 open source, with open governance through Linux Foundation Decentralized Trust.</p>"},{"location":"#programmable-privacy-for-evm","title":"Programmable privacy for EVM","text":"<p>The Ethereum Virtual Machine (EVM) powers over 80% of global blockchain projects, making it the 'de facto' runtime environment for both enterprise and permissionless networks.</p> <p>However, there are requirements for enterprise use cases that are not met by the core standard of EVM. The Zeto project is part of a larger effort, the Paladin project, which brings latest generation of innovation in solving these requirements in the EVM ecosystem, and provides a comprehensive enterprise grade Apache 2.0 open source stack to deliver them.</p> <ul> <li>Anonymity for all parties involved in transactions</li> <li>Confidential transaction details</li> <li>Transaction history masking to prevent tracking</li> <li>Selective data sharing</li> <li>Confidential business logic</li> <li>Privacy preserving smart contracts</li> <li>Private token and asset management</li> <li>Atomic transactions across privacy domains</li> </ul>"},{"location":"faqs/","title":"Frequently Asked Questions","text":""},{"location":"faqs/#can-i-develop-a-self-custody-wallet-for-zeto-tokens","title":"Can I develop a self-custody wallet for Zeto tokens?","text":"<p>Due to the usage of UTXOs for the onchain token commitments, a \"wallet\" for Zeto will be architecturally similar to a Bitcoin wallet. It must index the entire chain of blocks since the deployment of the Zeto contract, in order to discover all the Zeto tokens that belong to the user. Figuring out the user's balance is achieved by adding together the values of all the UTXOs owned by the account, meaning the <code>owner public key</code> part of the commitment hash matches the user's Babyjubjub public key.</p> <p>Spending Zeto tokens requires surveying the account's UTXOs and select the collection of tokens that makes the most sense for the requested amount.</p> <p>Finally the wallet must be able to generate the appropriate ZK proofs for the intended transactions to send to the Zeto smart contract.</p> <p>In summary, a Zeto wallet is a sophisticated software that will be more complex than typical self-custody wallets such as Metamask, which only needs to manage signing keys and make JSON-RPC calls against the target blockchain. Refer to an existing implementation of a Zeto client such as Paladin for details.</p>"},{"location":"faqs/#what-sdk-should-i-use-in-my-application-to-work-with-zeto-tokens","title":"What \"SDK\" should I use in my application to work with Zeto tokens?","text":"<p>As explained above, working with Zeto tokens requires a sophisticated client such as Paladin. Even though the Zeto project provides a go-sdk, to build a robust client for Zeto is a major engineering effort. Starting with Paladin is highly recommended instead of re-implementing one from scratch.</p>"},{"location":"faqs/#why-do-i-need-zeto-tokens-if-i-already-get-privacy-with-zk-rollups-or-validium-layer-2s","title":"Why do I need Zeto tokens if I already get privacy with ZK rollups or Validium Layer 2's?","text":"<p>It's a common misconception that ZK rollups (Linea, zkSync, Polygon zkEVM, etc.) provides privacy. As of this writing, all the ZK rollups except Aztec use Zero Knowledge Proofs for scalability rather than privacy. All the transaction data are public information in two contexts:</p> <ul> <li>the L2 network is a transparent shared ledger, where all the transactions are broadcast to all the L2 nodes</li> <li>all the L2 transaction data are sent to the verifier contract in L1</li> </ul> <p>Due to the above two aspects, ZK rollups provides no privacy over L2 transactions.</p> <p>What about Validium L2's? They send hashes of the L2 transactions rather than the transaction data to L1, and uses DAC's (Data Availability Committees) to manage the transaction data. Even though there is no information exposure to L1, there is still no privacy due to the follow two aspects:</p> <ul> <li>the L2 network is a transparent shared ledger, where all the transactions are broadcast to all the L2 nodes</li> <li>the DAC must make all the transaction data available to anyone who wants to ask for it, in order for a L2 user to generate a merkle proof to withdraw their assets from the Validium network's L1 contract</li> </ul> <p>In summary, even if a L2 network uses ZKP, there is no privacy over the transactions that are sent to the L2 network.</p>"},{"location":"faqs/#how-is-zeto-different-than-aztec","title":"How is Zeto different than Aztec?","text":"<p>As mentioned above, Aztec is a rollup L2 that offers privacy at the protocol level. Zeto shares some common designs with Aztec:</p> <ul> <li>UTXOs: both Zeto and Aztec use UTXOs (Unspent Transaction Outputs) as the onchain state model</li> <li>private storage: client maintains private storage that persists secrets belonging to a user</li> <li>ZKP: zero knowledge proofs are used to ensure transactions are honestly constructed and state transitions are correct</li> </ul> <p>On the other hand, there are significant differences:</p> <ul> <li>target EVM: Zeto is implemented on top of a vanilla EVM, making it compatible with any EVM blockchain including both L1's and L2's. On the other hand, Aztec is an L2 protocol and relies on a specialized EVM. So far Zeto has been tested on multiple EVM based L1 and L2 blockchains:</li> <li>Ethereum</li> <li>Polygon</li> <li>Linea</li> <li>Arbitrum</li> <li>ZK circuit design language: Zeto currently uses circom which is the most widely used DSL for designing ZK circuits, and most widely supported by the different proving systems (groth16, plonk, fflonk, nova). To develop ZK circuits for Aztec, you use Noir.</li> </ul>"},{"location":"glossary/","title":"Glossary","text":"UTXO <p>Unspent Transaction Output. First pioneered by the Bitcoin network, the UTXO state model uses individual tokens similar to coins to represent states. Instead of maintaining a per-account state (such as ERC20 balances) as is in the account model, which is the other significant state model, UTXO states are independent to each other. Each UTXO defines its own spending rules that must be satisfied in order to spend.</p> Commitment <p>Every UTXO state maintained by the Zeto smart contract is a representation of the secrets (value, ownership) behind the token. The form of representation is a secure cryptographic hash of the secrets. This is formally called a commitment because it \"locks down\" the secrets. Any attempts to change the secrets such as the value or the ownership of a token will result in a different hash. These commitments are critical in verifying ZKPs to process transactions.</p> Nullifier <p>It's a special type of hash that is securely, and secretly, bound to an UTXO. It's sole purpose is to demonstrate that a UTXO has been spent, although which particular UTXO is known only to the owner. Only the owner of an UTXO can produce the proper nullifier for the UTXO, which can be proven with a ZKP. Nullifiers are used when history masking is required, so that no one other than the owner of a UTXO can find out which UTXO have been spent by a transaction.</p>"},{"location":"advanced/erc20-tokens-integration/","title":"ERC20 Tokens integration","text":"<p>All fungible Zeto implementations support integration with an ERC20 contract via <code>deposit</code> and <code>withdraw</code> functions.</p> <p></p>"},{"location":"advanced/erc20-tokens-integration/#deposit","title":"Deposit","text":"<p>When depositing, users take their balances in ERC20 and exchanges for the same amount in Zeto tokens. The deposited amount will be transfered to the Zeto contract to own, until the time when a withdraw is called.</p> <p>The ZKP circuit for the deposit function contains the following statements:</p> <ul> <li>the commitments for the output UTXOs are based on positive numbers</li> <li>the commitments for the output UTXOs are well formed, obeying the <code>hash(value, owner public key, salt)</code> formula</li> <li>the sum of the output UTXO values are returned as the output signal, which can be compared with the <code>amount</code> value in the transaction call. aka <code>depositAmount == sum(outputs)</code></li> </ul> <p>One obvious observation with the deposit function is that it leaks the value of the output UTXO. For instance, consider the following transaction:</p> <pre><code>deposit(amount, outputUTXO, proof);\n</code></pre> <p>The output UTXO's value will be equal to the <code>amount</code>. To mitigate this, the output is an array of UTXOs, of size <code>2</code>. This way the exact value of each of the UTXOs in the output is unknown except by the owner(s).</p>"},{"location":"advanced/erc20-tokens-integration/#withdraw","title":"Withdraw","text":"<p>When withdrawing, users spend their UTXOs in the Zeto contract and request for the corresponding amount to be transferred to their Ethereum account in the ERC20 contract.</p> <p>The ZKP circuit for the withdraw function contains the following statements:</p> <ul> <li>the commitments for the output UTXOs are based on positive numbers</li> <li>the commitments for the input and output UTXOs are well formed, obeying the <code>hash(value, owner public key, salt)</code> formula</li> <li>the sum of the input UTXO values is subtracted by the sum of the output UTXO values, with the result returned as the output signal, which can be compared with the <code>amount</code> value in the transaction call. aka <code>sum(inputs) == sum(outputs) + withdarwAmount</code></li> </ul>"},{"location":"advanced/erc20-tokens-integration/#how-to-use-erc20-integration","title":"How to use ERC20 integration","text":"<p>It's very easy to enable the ERC20 integration on any fungible Zeto implementation. Call <code>setERC20(erc20_contract_address)</code> to configure the ERC20 contract that the Zeto token should work with. That's it!</p>"},{"location":"advanced/erc20-tokens-integration/#depositwithdraw-vs-mint","title":"deposit/withdraw vs. mint","text":"<p>A solution developer who considers using the ERC20 integration feature must take into account how this works alongside the <code>mint</code> function. While the <code>mint</code> function preserves the privacy of new token issuance inside the Zeto contract, it could lead to an insufficient balance in the ERC20 contract when the <code>withdraw</code> function is invoked.</p> <p>Consider the following sequence of events:</p> <ul> <li>The Zeto contract is deployed and configured to work with an ERC20 contract</li> <li>Alice deposits 100 from her ERC20 balance <p>Zeto contract's balance becomes 100</p> </li> <li>The regulator mints 50 to Alice</li> <li>Bob deposits 100 from his ERC20 balance <p>Zeto contract's balance becomes 200</p> </li> <li>Alice withdraws all her 150 Zeto tokens <p>Zeto contract's balance becomes 50</p> </li> <li>Bob attempts to withdraw 100 <p>This will fail because the Zeto contract's balance is below the requested amount</p> </li> </ul>"},{"location":"advanced/locks/","title":"Locking UTXOs","text":"<p>In a typical atomic swap flow, based on the popular ERC20 token standard, the tokens from the trading parties are transferred to an escrow contract, which then coordinates the settlements with all the trading parties to ensure safety for all the involved parties.</p> <p>This type of swap design is not possible with Zeto tokens, unfortunately. An escrow contract can not own tokens because Solidity contract doesn't have the ability to generate ZK proofs required to spend Zeto tokens.</p> <p>This is where the <code>locking</code> mechanism comes in.</p> <p></p> <p>As illustrated above, regular (unlocked) UTXOs can be spent by any Ethereum account submitting a valid proof. This is an important privacy feature because it doesn't require the Ethereum transaction signing account to be tied to the ownership of the Zeto tokens. As a result, the Zeto tokens owner can use a different Ethereum signing key for each transaction, to avoid their transaction history to be analyzed based on the base ledger transactions.</p> <p>On the other hand, a UTXO can be locked with a designated <code>spender</code>, which is an Ethereum account address. The owner of the token is still required to produce a valid proof, which then must be submitted by the designated <code>spender</code> key, signing the transaction to spend the locked UTXO(s).</p> <p></p> <p>In the locking transaction above, a locked UTXO, #3 was created. The owner is still Alice, but the spender has been set to the address of an escrow contract. This means Alice as the owner can no longer spend UTXO #3, even though she can produce a valid spending proof. In order to spend a locked UTXO, a valid proof must be submitted by the designated spender.</p>"},{"location":"advanced/locks/#lock-then-delegate","title":"Lock, then delegate","text":"<p>The following diagram illustrates a typical flow to use the locking mechanism.</p> <p></p> <ul> <li>Alice and Bob are in a bilateral trade where Alice sends Bob 100 Zeto tokens for payment, at the same time Bob sends Alice some asset tokens which are omitted from the diagram</li> <li>In transaction 1, <code>Tx1</code>, Alice calls <code>lock()</code> to lock 100 into a new UTXO #3, by spending two existing UTOXs #1 and #2. The transaction also creates #4 for the remainder value, which is unlocked. This transaction designates the escrow contract as the spender for the locked UTXO #3</li> <li>Alice then sends another transaction, <code>Tx2</code>, to call <code>approvePayment()</code> on the escrow contract and sends a valid proof to the contract. This proof can be used to spend the locked #3 UTXO and create #5, which will be owned by Bob <p>the contract will verify that the proof is valid for the intended UTXO spending</p> </li> <li>Alice and Bob continues with the trade using the escrow contract logic. The details of the remainder of the trade flow are omitted</li> <li>When the trade setup is complete, and ready to settle atomically, a party can call the escrow contract to carry out the execution phase. The escrow contract calls Zeto to <code>transferLocked()</code> the locked UTXO #3 and creates #5, as was originally intended in the trade setup phase</li> </ul>"},{"location":"advanced/shield-unshield/","title":"Zeto as Cryptos Mixer","text":"<p>As illustrated above, DeFi users can leverage the Zeto token contract as a privacy-preserving mixer by shielding (depositing) their cryptocurrency tokens into the Zeto contract in exchange for Zeto tokens of equivalent value. These Zeto tokens can later be unshielded (withdrawn) into cryptocurrency tokens using a different wallet. This process effectively allows a user to move funds from one wallet to another, without leaving a traceable link between the deposit and withdrawal.</p> <p>This untraceability is achieved through the use of nullifiers during the withdrawal process, which obscure the specific Zeto tokens (UTXOs) being spent. Because external observers cannot correlate the nullifiers used in withdrawals with the tokens created during deposits, it becomes infeasible to link the cryptocurrency that entered the mixer with what comes out.</p> <p>This enables DeFi users to maintain strong privacy while engaging in DeFi activities.</p>"},{"location":"advanced/shield-unshield/#sample-implementation","title":"Sample Implementation","text":"<p>A sample implementation of the above flow is available in the integration test at usdc-shielding.ts.</p>"},{"location":"advanced/shield-unshield/#regulatory-compliance","title":"Regulatory Compliance","text":"<p>Regulatory compliance can be readily achieved by enforcing KYC at the Zeto token level, as demonstrated in the implementation Zeto_AnonNullifierKyc. Before depositing tokens into Zeto, a DeFi user must first complete KYC verification for their Zeto wallet. This ensures that all users utilizing the mixer functionality comply with regulatory requirements.</p>"},{"location":"advanced/utxo-array-sizes/","title":"Supporting different UTXO array sizes","text":"<p>Using ZK proofs presents a special challenge for supporting UTXO inputs and outputs that are of different sizes. For instance, a transaction proposal that consumes 1 UTXO, owned by Alice, but generates 3 UTXOs to be owned by Bob, Charlie and Alice, will require a different circuit for the proof than a transaction that consumes 2 UTXOs and generates 2 UTXOs.</p> <p> Using different array sizes for the input signals require different verification circuits</p> <p>This is because a ZKP circuit must always perform the exact same computation. Therefore, if there are arrays in the input signals, the size of the arrays must be known at compile time.</p> <p> Using the same array sizes for the input signals require the same verification circuit</p> <p>For all Zeto token implementations, two sizes are chosen for the circuits: <code>2</code> and <code>10</code>.</p>"},{"location":"advanced/utxo-array-sizes/#size-2","title":"Size = 2","text":"<p>For example, the following top-level circuit is for the token implementation <code>Zeto_Anon</code>,</p> <pre><code>[file: zkp/circuits/anon.circom]\ninclude \"./basetokens/anon_base.circom\";\n\ncomponent main { public [ inputCommitments, outputCommitments ] } = Zeto(2, 2);\n</code></pre> <p>The <code>Zeto(2, 2)</code> part provides fixed values for the parameterized circuit template from <code>basetokens/anon_base.circom</code>, which looks like this,</p> <pre><code>template Zeto(nInputs, nOutputs) {\n  signal input inputCommitments[nInputs];\n  signal input inputValues[nInputs];\n  signal input inputSalts[nInputs];\n  signal input outputCommitments[nOutputs];\n  signal input outputValues[nOutputs];\n  signal input outputSalts[nOutputs];\n  signal input outputOwnerPublicKeys[nOutputs][2];\n\n  ...\n}\n</code></pre> <p>The parameterized template support different array sizes for both the inputs and outputs, but for the final circuit to be compiled, we set the size to <code>2</code> for both the inputs and outputs. This corresponds to the Solidity function in the token implementation:</p> <pre><code>function transfer(\n  uint256[] memory inputs,\n  uint256[] memory outputs,\n  Commonlib.Proof calldata proof,\n  bytes calldata data\n) public returns (bool) { ... }\n</code></pre> <p>When a transaction calls this function with inputs and outputs sizes of 1 or 2, the Solidity code will pad the arrays to size 2, and use the verifier library generated from the above circuit (<code>Zeto(2, 2)</code>) to verify the proof.</p>"},{"location":"advanced/utxo-array-sizes/#size-10","title":"Size = 10","text":"<p>To support array size of 10 in the input signals, we simply set the size parameters to <code>10</code> in the top-level circuit:</p> <pre><code>[file: zkp/circuits/anon_batch.circom]\ninclude \"./basetokens/anon_base.circom\";\n\ncomponent main { public [ inputCommitments, outputCommitments ] } = Zeto(10, 10);\n</code></pre>"},{"location":"concepts/basics/","title":"Basic Concepts","text":"<p>Zeto is built on the following fundamental concepts.</p>"},{"location":"concepts/basics/#onchain-state-model-utxo","title":"Onchain state model: UTXO","text":"<p>The smart contract for a token economy must maintain states onchain. There are two ways to model states: account vs. UTXO.</p> <ul> <li>The account model is very popular in the existing token standards such as ERC20/721/1155 etc. Each account is an entry in a map that the smart contract maintains, with the value being the account's state such as current balance, or list of assets. A transaction updates the states of one or more accounts.</li> <li>The UTXO model works very differently, by creating states that are independent to each other. Each UTXO state is in one of two modes: unspent or spent. A transaction consumes unspent states, at which point they become spent, and produces new (unspent) states. Each UTXO state specifies the spending rules that must be satisfied when a transaction attempts to spend it.</li> </ul> <p></p>"},{"location":"concepts/basics/#utxo-for-better-parallel-processing","title":"UTXO for better parallel processing","text":"<p>The UTXO model is adopted for Zeto instead of the account model, for better support of parallel processing. Due to the necessity of maintaining private states offchain in order to achieve privacy, the client must continuously keep their private states in sync with the smart contract. Using an account model makes it more difficult to achieve this because incoming transfers from other parties would invalidate an account's state, making the account owner unable to spend from its account unless the private state has been sync'ed again. Solutions to this issue, often referred to as front-running, typically involve a spending window with a pending queue. One example of this is Zether, which describes an <code>epoch</code> construct with pending transaction queues to address the front-running problem. Using epochs results in limited parallel processing of transactions from the same spending account.</p> <p>With a UTXO model, on the other hand, since each state is independent of the others, spending multiple UTXOs at the same time, even if they call come from the same owner, can be easily achieved.</p>"},{"location":"concepts/basics/#utxo-for-better-anonymity","title":"UTXO for better anonymity","text":"<p>With an account model, given that the states are mapped to the owning accounts in the onchain storage, there is an inherent challenge to anonymity, where checking which account was updated by a transaction would reveal the counterparties of a transaction. This could be mitigated by using anonymity sets, where more accounts besides the real sender and receiver of a transaction are updated with an encrypted zero value. However this increases the gas cost of transactions.</p> <p>With the UTXO model, since each UTXO state describes its own ownership, in a masked form (<code>hash(value, owner public key, salt)</code>), there is no revelation of the owning account when a UTXO is spent or produced. Furthermore, the entitlement to spend the private UTXO token is demonstrated by the ZK proof, rather than the transaction signer (aka <code>msg.sender</code>). This allows Zeto transactions to be signed by any accounts. Zeto clients are encouraged to use one-time signing keys to submit transactions, such as those from an HD wallet.</p>"},{"location":"concepts/basics/#commitments","title":"Commitments","text":"<p>Each UTXO is tracked by the smart contract as a hash of the following components: value (for fungible Zeto) or token Id (for non-fungible Zeto), owner public key and salt. These are called commitments. They serve several important purposes:</p> <ul> <li>Representing the existence of a Zeto token. A Zeto token's value is recognized only if it's commitment is known to the smart contract that maintains the token economy.</li> <li>Hiding the secret information about a Zeto token. The value or token Id and the ownership information are hidden behind the secure hash string, which can not be reverse-engineered back to the secerts.</li> <li>Acting as the public inputs for verifying ZK proofs. All Zeto transactions consume some existing UTXOs and produce some new UTXOs. For the smart contract to be convinced that a transaction is valid, a ZK proof must be provided that demonstrates a transaction proposal conforming to the policies of the specific token implementation. The commitment hashes are critical public inputs in almost all such ZK proof verifications.</li> </ul>"},{"location":"concepts/basics/#finality","title":"Finality","text":"<p>Each transaction's validity is verified by the smart contract before allowing the proposed input UTXOs to be nullified and the output UTXOs to come into existence. In other words, this is not an optimistic design and as such does not rely on a multi-day challenge period before a transaction is finalized. Every transaction is immediately finalized once it's mined into a block.</p>"},{"location":"concepts/how-zeto-works/","title":"How Zeto tokens work","text":"<ul> <li>Party A owns 3 Zeto tokens at the beginning: <code>#1, #2, #3</code>. The 3 tokens have been minted in the Zeto smart contract and represented by their commitments, aka <code>hash(value, owner public key, salt)</code></li> <li>As the owner of the tokens, party A also has access to the secrets that the commitments can be opened to, namely the value and salt. The secrets are represented as private states: <code>s1, s2, s3</code></li> <li>How party A obtained the secrets for the owned tokens, is dependent on the specific Zeto implementation. It can be from offchain channels or from onchain (encrypted) data</li> <li>Party A sends transaction <code>Tx1</code> to transfer some value to party B. The transaction consumes 2 tokens <code>#1, #2</code> and produces 2 new tokens <code>#4, #5</code>. <code>#5</code> is the value to be transferred to party B. <code>#4</code> is the remainder value that goes back to party A</li> <li>Even though party A knows the secrets of <code>#5</code>, they won't be able to spend the token because party A is not the owner of the token.</li> <li>Ownership verification is enforced by the Zeto smart contract when it verifies the zero knowledge proofs. Each ZKP circuit ensures that the sender's private key is used as a private input signal to derive the public key, which is then hashed to calculate the commitments</li> <li>Party B sends transaction <code>Tx2</code> to transfer some value to party C. This works the same as <code>Tx1</code></li> <li>All parties get the commitments, <code>#1, #2, ... #7</code>, from the onchain events</li> </ul> <p>The above diagram illustrates that the secrets are transmitted from the sender to the receiver in an off-chain secure channel. Other means of sharing the secrets are avaiable in Zeto token implementations. For instance, the Zeto_AnonEnc implementation includes encrypted secrets in the transaction input, and emits an event with the encrypted values. The encrypted values can only be decrypted by the receiver.</p>"},{"location":"concepts/how-zeto-works/#ec-cryptography","title":"EC Cryptography","text":"<p>Performing key pair operations, such as deriving the public key from the private key, in the ZKP circuit requires ZKP-friendly curves, for which we picked Babyjubjub instead of the regular Ethereum curve (secp256k1).</p>"},{"location":"concepts/how-zeto-works/#transaction-signing","title":"Transaction Signing","text":"<p>Another implication to the usage of ZKPs as transaction validity proof and the usage of the Babyjubjub curve, is that the signer of the transaction, eg. <code>msg.sender</code>, no longer bears the same significance as in other token implementations such as ERC20, ERC721, where the signer's EVM account address holds the actual assets. In Zeto tokens, it's the Babyjubjub public keys that hold the entitlement to spend the tokens. In fact, the applications are encouraged to use a different signing key for each transaction, to avoid leaking transaction behaviors and breaking anonymity.</p>"},{"location":"contributing/asking-a-question/","title":"Asking a Question","text":"<p>Tip</p> <ul> <li>check the FAQs to see if your question has already been asked.</li> <li>make sure you provide all relevant details.</li> <li>include information about what you have already tried.</li> <li>review How to Ask Technical Questions to Get Quality Answers prior to asking your question.</li> </ul>"},{"location":"contributing/asking-a-question/#chat","title":"Chat","text":"<p>Hyperledger\u2019s Discord server is the place to go for real-time chat about everything from quick help to involved discussions.</p> <p>For general Zeto discussions, join the Discord server and visit Labs/Zeto.</p>"},{"location":"contributing/asking-a-question/#mailing-lists","title":"Mailing Lists","text":"<p>The Paladin mailing list is hosted by the Hyperledger Foundation: https://lists.lfdecentralizedtrust.org.</p>"},{"location":"contributing/how-to-contribute/","title":"How to Contribute","text":""},{"location":"contributing/how-to-contribute/#ways-to-contribute","title":"Ways to Contribute","text":"<p>Contributions from the development community help improve the capabilities of Zeto. These contributions are the most effective way to make a positive impact on the project.</p> <p>Ways you can contribute:</p> <ul> <li>Bugs or issues: Report problems or defects found when working with the project (see Reporting a Bug)</li> <li>Core features and enhancements: Provide expanded capabilities or optimizations</li> <li>Documentation: Improve existing documentation or create new information</li> <li>Tests: Add functional, performance, or scalability tests</li> </ul> <p>Issues can be found in GitHub. Any unassigned items are probably still open. When in doubt, ask on Discord about a specific issue (see Asking a Question). We also use the #good-first-issue tag to represent issues that might be good for first timers.</p>"},{"location":"contributing/how-to-contribute/#the-commit-process","title":"The Commit Process","text":"<p>Zeto is Apache 2.0 licensed and accepts contributions via GitHub pull requests. When contributing code, please follow these guidelines:</p> <ul> <li>Fork the repository and make your changes in a feature branch</li> <li>Include unit and integration tests for any new features and updates to existing tests</li> <li>Ensure that the unit and integration tests run successfully prior to submitting the pull request.</li> </ul>"},{"location":"contributing/how-to-contribute/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>A pull request can contain a single commit or multiple commits. The most important guideline is that a single commit should map to a single fix or enhancement. Here are some example scenarios:</p> <ul> <li>If a pull request adds a feature but also fixes two bugs, the pull request should have three commits: one commit for the feature change and two commits for the bug fixes.</li> <li>If a PR is opened with five commits that contain changes to fix a single issue, the PR should be rebased to a single commit.</li> <li>If a PR is opened with several commits, where the first commit fixes one issue and the rest fix a separate issue, the PR should be rebased to two commits (one for each issue).</li> </ul> <p>Important</p> <p>Your pull request should be rebased against the current master branch. Do not merge the current master branch in with your topic branch. Do not use the Update Branch button provided by GitHub on the pull request page.</p>"},{"location":"contributing/how-to-contribute/#commit-messages","title":"Commit Messages","text":"<p>Commit messages should follow common Git conventions, such as using the imperative mood, separate subject lines, and a line length of 72 characters. These rules are well documented in Chris Beam's blog post.</p>"},{"location":"contributing/how-to-contribute/#signed-off-by","title":"Signed-off-by","text":"<p>Each commit must include a \"Signed-off-by\" line in the commit message (<code>git commit -s</code>). This sign-off indicates that you agree the commit satisfies the Developer Certificate of Origin (DCO).</p>"},{"location":"contributing/how-to-contribute/#commit-email-address","title":"Commit Email Address","text":"<p>Your commit email address must match your GitHub email address. For more information, see https://help.github.com/articles/setting-your-commit-email-address-in-git/</p>"},{"location":"contributing/how-to-contribute/#important-github-requirements","title":"Important GitHub Requirements","text":"<p>A pull request cannot merged until it has passed these status checks:</p> <ul> <li>The build must pass all checks</li> <li>The PR must be approved by at least two reviewers without any   outstanding requests for changes</li> </ul>"},{"location":"contributing/how-to-contribute/#inclusive-language","title":"Inclusive Language","text":"<ul> <li>Consider that users who will read the source code and documentation are from different background and cultures and that they have different preferences.</li> <li>Avoid potential offensive terms and, for instance, prefer \"allow list and deny list\" to \"white list and black list\".</li> <li>We believe that we all have a role to play to improve our world, and even if writing inclusive code and documentation might not look like a huge improvement, it's a first step in the right direction.</li> <li>We suggest to refer to Microsoft bias free writing guidelines and Google inclusive doc writing guide as starting points.</li> </ul>"},{"location":"contributing/how-to-contribute/#credits","title":"Credits","text":"<p>This document is based on Hyperledger Sawtooth's Contributing documentation.</p>"},{"location":"contributing/reporting-a-bug/","title":"Reporting a Bug","text":"<p>To report a bug, submit an issue in our public issue tracker.</p> <p>When reporting an issue, please provide as much detail as possible about how to reproduce it. If possible, explain how to reproduce the issue. Details are very helpful. Please include the following information:</p> <ul> <li>Operating system and version (if Mac, include the processor)</li> <li>Project version</li> <li>Environment details (virtual, physical, etc.)</li> <li>Steps to reproduce the issue</li> <li>Actual results</li> <li>Expected results</li> </ul>"},{"location":"contributing/requesting-a-change/","title":"Requesting a Change","text":"<p>Zeto is a powerful tool which serves a wide range of use cases. Put yourself in our shoes \u2013 with a project of this size, it can be challenging to maintain existing functionality while constantly adding new features at the same time. We highly value every idea or contribution from our community, and we kindly ask you to take the time to read the following guidelines before submitting your change request in our public issue tracker. This will help us better understand the proposed change, and how it will benefit the community.</p> <p>This guide is our best effort to explain the criteria and reasoning behind our decisions when evaluating change requests and considering them for implementation.</p>"},{"location":"contributing/requesting-a-change/#before-creating-an-issue","title":"Before creating an issue","text":"<p>Before you invest your time to fill out and submit a change request, we kindly ask you to do some preliminary work by answering some questions to determine if your idea is a good fit and matches the project's philosophy and tone.</p> <p>Please find answers to the following questions before creating an issue.</p>"},{"location":"contributing/requesting-a-change/#its-not-a-bug-its-a-feature","title":"It's not a bug, it's a feature","text":"<p>Change requests are intended for suggesting minor adjustments, ideas for new features, or to influence the project's direction and vision. It is important to note that change requests are not intended for reporting bugs, as they're missing essential information for debugging.</p> <p>If you want to report a bug, please refer to our bug reporting guide instead.</p>"},{"location":"contributing/requesting-a-change/#source-of-inspiration","title":"Source of inspiration","text":"<p>If you have seen your idea implemented in similar project, make sure to collect enough information on its implementation before submitting, as this allows us to evaluate potential fit more quickly. Explain what you like and dislike about the implementation.</p>"},{"location":"contributing/requesting-a-change/#benefit-for-the-community","title":"Benefit for the community","text":"<p>Our Discord server is the best place to connect with our community. When evaluating new ideas, it's essential to seek input from other users and consider alternative viewpoints. This approach helps to implement new features in a way that benefits a large number of users.</p>"},{"location":"contributing/requesting-a-change/#issue-template","title":"Issue template","text":"<p>Now that you have taken the time to do the necessary preliminary work and ensure that your idea meets our requirements, you are invited to create a change request. The following guide will walk you through all necessary steps to help you submit a comprehensive and useful issue:</p> <ul> <li>Title</li> <li>Context optional</li> <li>Description</li> <li>Related links</li> <li>Use cases</li> <li>Visuals optional</li> <li>Checklist</li> </ul>"},{"location":"contributing/requesting-a-change/#title","title":"Title","text":"<p>A good title is short and descriptive. It should be a one-sentence executive summary of the idea, so the potential impact and benefit for the community can be inferred from the title.</p>"},{"location":"contributing/requesting-a-change/#context","title":"Context optional","text":"<p>Before describing your idea, you can provide additional context for us to understand what you are trying to achieve. Explain the circumstances in which you're using Zeto, and what you think might be relevant. Don't write about the change request here.</p> <p>Why we need this</p> <p>Some ideas might only benefit specific settings, environments or edge cases. With a little context, change requests can be prioritized more accurately.</p>"},{"location":"contributing/requesting-a-change/#description","title":"Description","text":"<p>Next, provide a detailed and clear description of your idea. Explain why your idea is relevant to Zeto and must be implemented here, and not in one of its dependencies.</p> <ul> <li> <p>Explain the what, not the why \u2013 don't explain   the benefits of your idea here, we're getting there.   Focus on describing the proposed change request as precisely as possible.</p> </li> <li> <p>Keep it short and concise \u2013 be brief and to the point when describing   your idea, there is no need to over-describe it. Maintainers and future   users will be grateful for having to read less.</p> </li> <li> <p>One idea at a time \u2013 if you have multiple ideas that don't belong   together, please open separate change requests for each of those ideas.</p> </li> <li> <p> Stretch goal \u2013 if you have a customization or another way to add the proposed change, you can help other users by sharing it here before we maintainers can add it to our code base.</p> </li> </ul> <p>Why we need this</p> <p>To understand and evaluate your proposed change, we need to have a clear understanding of your idea. By providing a detailed and precise description, you can help save you and us time spent discussing further clarification of your idea in the comments.</p>"},{"location":"contributing/requesting-a-change/#related-links","title":"Related links","text":"<p>Please provide any relevant links to issues, discussions, or documentation sections related to your change request. If you (or someone else) already discussed this idea with the community on our discussion board, please include the link to the discussion as well.</p> <p>Why we need this</p> <p>Related links help us gain a comprehensive understanding of your change request by providing additional context. Additionally, linking to previous issues and discussions allows us to quickly evaluate the feedback and input already provided by the community.</p>"},{"location":"contributing/requesting-a-change/#use-cases","title":"Use cases","text":"<p>Explain how your change request would work from a user's perspective \u2013 what's the expected impact and why does it not only benefit you, but other users? How many of them? Furthermore, would it potentially break existing functionality?</p> <p>Why we need this</p> <p>Understanding the use cases and benefits of an idea is crucial in evaluating its potential impact and usefulness for the project and its users. This information helps us to understand the expected value of the idea and how it aligns with the goals of the project.</p>"},{"location":"contributing/requesting-a-change/#visuals","title":"Visuals optional","text":"<p>We now have a clear and detailed description of your idea, including information on its potential use cases and relevant links for context. If you have any visuals, such as sketches, screenshots, mockups, or external assets, you may present them in this section.</p> <p>Tip</p> <p>You can drag and drop the files here or include links to external assets.</p> <p>Additionally, if you have seen this change, feature, or improvement used elsewhere, please provide an example by showcasing it and describing how it was implemented and incorporated.</p> <p>Why we need this</p> <p>Illustrations and visuals can help us maintainers better understand and envision your idea. Screenshots, sketches, or mockups can create an additional level of detail and clarity that text alone may not be able to convey. Also, seeing how your idea has been implemented in other projects can help us understand its potential impact and feasibility in Zeto, which helps us maintainers evaluate and triage change requests.</p>"},{"location":"contributing/requesting-a-change/#checklist","title":"Checklist","text":"<p>Thanks for following the change request guide and creating a high-quality change request. This section ensures that you have read this guide and have worked to your best knowledge to provide us with every piece of information to review your idea for Zeto.</p> <p>We'll take it from here.</p>"},{"location":"contributing/requesting-a-change/#credits","title":"Credits","text":"<p>This document is based on Material for MkDocs Requesting a Change.</p>"},{"location":"implementations/","title":"Overview of Zeto Token Implementations","text":"<p>Zeto is not a single privacy-preserving token implementation. It's a collection of implementations that meet a wide range of requirements in different use cases. The collection will continue to grow as new patterns are implemented.</p> <p>Below is a summary and comparison table among the current list of implementations.</p> Fungible Token Implementation Anonymity History Masking Locking Encryption KYC Non-repudiation Gas Cost (estimate) Zeto_Anon - - - - 326,583 Zeto_AnonNullifier - - - 2,005,587 Zeto_AnonEnc - - - 425,338 Zeto_AnonEncNullifier - - 2,472,994 Zeto_AnonNullifierKyc - - 2,310,424 Zeto_AnonEncNullifierKyc - 2,414,345 Zeto_AnonEncNullifierNonRepudiation - 2,763,071 Non-Fungible Token Implementation Anonymity History Masking Locking Encryption KYC Non-repudiation Gas Cost (estimate) Zeto_NfAnon - - - - 271,890 Zeto_NfAnonNullifier - - - 1,450,258 <p>The various patterns in this project use Zero Knowledge Proofs (ZKP) to demonstrate the validity of the proposed transaction. There is no centralized party to trust as in the Notary pattern, which is not implemented in this project but in the Paladin project.</p> <p>Using ZKPs as validity proofs, each participant can independently submit transactions to the smart contract directly. As long as the participant is able to produce a valid proof, the transaction will be successfully verified and allowed to go through.</p> <p>This project includes multiple ZKP circuits to support various privacy levels with Zeto.</p>"},{"location":"implementations/anon/","title":"Zeto_Anon","text":"Anonymity History Masking Encryption KYC Non-repudiation Gas Cost (estimate) - - - - 326,583 <p>This is the simplest version of the ZKP circuit. Because the secrets required to open the commitment hashes, namely the output UTXO value and salt, are NOT published as part of the transaction payload, using this version requires the secrets to be transmitted from the sender to the receiver in off-chain channels.</p> <p>The statements in the proof include:</p> <ul> <li>each value in the output commitments must be a positive number in the range 0 ~ (2**40 - 1)</li> <li>the sum of the input values match the sum of output values</li> <li>the hashes in the input and output match the hash(value, salt, owner public key) formula</li> <li>the sender possesses the private BabyJubjub key, whose public key is part of the pre-image of the input commitment hashes</li> </ul> <p>There is no history masking, meaning the associations between the consumed input UTXOs and the output UTXOs are in the clear.</p> <p></p>"},{"location":"implementations/anon_enc/","title":"Zeto_AnonEnc","text":"Anonymity History Masking Encryption KYC Non-repudiation Gas Cost (estimate) - - - 425,338 <p>This verison of the ZKP circuit adds encryption that makes it possible to provide data availability onchain. The circuit uses the sender's private key and the receiver's public key to generate a shared secret with ECDH, which guarantees that the receiver will be able to decrypt the values. The encrypted values include the value and salt of the output UTXO for the receiver. With these values the receiver is guaranteed to be able to spend the UTXO sent to them.</p> <p>The statements in the proof include:</p> <ul> <li>each value in the output commitments must be a positive number in the range 0 ~ (2**100 - 1)</li> <li>the sum of the input values match the sum of output values</li> <li>the hashes in the input and output match the hash(value, salt, owner public key) formula</li> <li>the sender possesses the private BabyJubjub key, whose public key is part of the pre-image of the input commitment hashes</li> <li>the encrypted values in the transaction are derived from the receiver's UTXO value and encrypted with a shared secret using the ECDH protocol between a random private key and the receiver (this guarantees data availability for the receiver, because the public key for the random private key used by the sender is published in the transaction)</li> </ul> <p>There is no history masking, meaning the association between the consumed input UTXOs and the output UTXOs are in the clear.</p>"},{"location":"implementations/anon_enc_nullifier/","title":"Zeto_AnonEncNullifier","text":"Anonymity History Masking Encryption KYC Non-repudiation Gas Cost (estimate) - - 2,472,994 <p>This implementation adds encryption, as described in the section above for Zeto_AnonEnc, to the pattern Zeto_AnonNullifier above.</p> <p>The statements in the proof include:</p> <ul> <li>each value in the output commitments must be a positive number in the range 0 ~ (2**100 - 1)</li> <li>the sum of the nullified values match the sum of output values</li> <li>the hashes in the output match the hash(value, salt, owner public key) formula</li> <li>the sender possesses the private BabyJubjub key, whose public key is part of the pre-image of the input commitment hashes, which match the corresponding nullifiers</li> <li>the nullifiers represent input commitments that are included in a Sparse Merkle Tree represented by the root hash</li> <li>the encrypted values in the transaction are derived from the receiver's UTXO value and encrypted with a shared secret using the ECDH protocol between a random private key and the receiver (this guarantees data availability for the receiver, because the public key for the random private key used by the sender is published in the transaction)</li> </ul>"},{"location":"implementations/anon_enc_nullifier_kyc/","title":"Zeto_AnonEncNullifier","text":"Anonymity History Masking Encryption KYC Non-repudiation Gas Cost (estimate) - 2,414,345 <p>This implementation adds encryption, as described in the section above for Zeto_AnonEnc, to the pattern Zeto_AnonNullifierKyc above.</p> <p>The statements in the proof include:</p> <ul> <li>each value in the output commitments must be a positive number in the range 0 ~ (2**100 - 1)</li> <li>the sum of the nullified values match the sum of output values</li> <li>the hashes in the output match the hash(value, salt, owner public key) formula</li> <li>the sender possesses the private BabyJubjub key, whose public key is part of the pre-image of the input commitment hashes, which match the corresponding nullifiers</li> <li>the nullifiers represent input commitments that are included in a Sparse Merkle Tree represented by the root hash</li> <li>the sender and receiver public keys are included in the Sparse Merkle Tree for the KYC registry, represented by the latest root hash known to the smart contract</li> <li>the encrypted values in the transaction are derived from the receiver's UTXO value and encrypted with a shared secret using the ECDH protocol between a random private key and the receiver (this guarantees data availability for the receiver, because the public key for the random private key used by the sender is published in the transaction)</li> </ul>"},{"location":"implementations/anon_enc_nullifier_non_repudiation/","title":"Zeto_AnonEncNullifierNonRepudiation","text":"Anonymity History Masking Encryption KYC Non-repudiation Gas Cost (estimate) - 2,763,071 <p>The concept of \"non-repudiation\" is introduced in this implementation pattern.</p> <p>Since all onchain states are hashes, with ownership information for the assets hidden, it's possible that a participant can send a transaction but subsequently deny it. Because the transaction signer account no longer reflects the identity of the asset owner, as discussed above, it will be impossible to know who was the sender of a transaction from purely looking at the onchain data, which is exactly the point for Zeto's anonymity support. This gives a malicious party the ability to gain repudiation, or deny that they were responsible for a past transaction.</p> <p>This implementation pattern addresses that concern by encrypting the ownership information of each UTXO involved in a transaction with an authority's registered key. Only the designated authority will be able to decrypt the ownership information. The encryption is performed inside the ZKP circuit, thus guaranteeing that they are the actual owners of the UTXOs.</p> <p>The statements in the proof include:</p> <ul> <li>each value in the output commitments must be a positive number in the range 0 ~ (2**100 - 1)</li> <li>the sum of the nullified values match the sum of output values</li> <li>the hashes in the output match the hash(value, salt, owner public key) formula</li> <li>the sender possesses the private BabyJubjub key, whose public key is part of the pre-image of the input commitment hashes, which match the corresponding nullifiers</li> <li>the nullifiers represent input commitments that are included in a Sparse Merkle Tree represented by the root hash</li> <li>the encrypted values in the transaction contains cipher texts derived from the receiver's UTXO values and encrypted with a shared secret using the ECDH protocol between a random private key and the receiver (this guarantees data availability for the receiver, because the public key for the random private key used by the sender is published in the transaction)</li> <li>the encrypted values in the transaction contains cipher texts derived from the receiver's UTXO values and encrypted with a shared secret using the ECDH protocol between a random private key and the authority's public key</li> </ul>"},{"location":"implementations/anon_nullifier/","title":"Zeto_AnonNullifier","text":"Anonymity History Masking Encryption KYC Non-repudiation Gas Cost (estimate) - - - 2,005,587 <p>To mask the association between the consumed UTXOs and the output UTXOs, we hide which UTXOs are being consumed by each transaction.</p> <p>To achieve this, we employ the usage of nullifiers. It's a unique hash derived from the unique commitment it consumes. For a UTXO commitment hash(value, salt, owner public key), the nullifier is calculated as hash(value, salt, owner private key). Only the owner of the commitment can generate the nullifier hash. Each transaction will record the nullifiers in the smart contract, to ensure that they don't get re-used (double spending).</p> <p></p> <p>In order to prove that the UTXOs to be spent actually exist, we use a merkle tree proof inside the zero knowledge proof circuit. The merkle proof is validated against a merkle tree root that is maintained by the smart contract. The smart contract keeps track of all the new UTXOs in each transaction's output commitments array, and uses a merkle tree to calculate the root hash. Then the ZKP circuit can use a root hash as public input, to prove that the input commitments (UTXOs to be spent), which are private inputs to the circuit, are included in the merkle tree represented by the root.</p> <p>The end result is that, from the onchain data, no one can figure out which UTXOs have been spent, while double spending is prevented.</p> <p>The statements in the proof include:</p> <ul> <li>each value in the output commitments must be a positive number in the range 0 ~ (2**40 - 1)</li> <li>the sum of the nullified values match the sum of output values</li> <li>the hashes in the output match the hash(value, salt, owner public key) formula</li> <li>the sender possesses the private BabyJubjub key, whose public key is part of the pre-image of the input commitment hashes, which match the corresponding nullifiers</li> <li>the nullifiers represent input commitments that are included in a Sparse Merkle Tree represented by the root hash</li> </ul> <p></p>"},{"location":"implementations/anon_nullifier_kyc/","title":"Zeto_AnonNullifierKyc","text":"Anonymity History Masking Encryption KYC Non-repudiation Gas Cost (estimate) - - 2,310,424 <p>The concept of \"KYC with privacy\" is introduced in this implementation pattern.</p> <p>How to enforce a policy of \"all senders and receivers of a transaction must be in a KYC registry\", while maintaining anomymity of the sender and the receiver? The solution is similar to how nullifiers are supported, via merkle tree proofs.</p> <p>The implementation of this pattern maintains a KYC registry in the smart contract as a Sparse Merkle Tree. The registry is maintained by a designated authority, and includes the public keys of entities that have cleared the KYC process. Each transaction must demonstrate that the public keys of the sender and the receivers are included in the KYC merkle tree, by generating a merkle proof and using it as a private input to the ZKP circuit.</p> <p>The statements in the proof include:</p> <ul> <li>each value in the output commitments must be a positive number in the range 0 ~ (2**100 - 1)</li> <li>the sum of the nullified values match the sum of output values</li> <li>the hashes in the output match the hash(value, salt, owner public key) formula</li> <li>the sender possesses the private BabyJubjub key, whose public key is part of the pre-image of the input commitment hashes, which match the corresponding nullifiers</li> <li>the nullifiers represent input commitments that are included in a Sparse Merkle Tree represented by the root hash</li> <li>the sender and receiver public keys are included in the Sparse Merkle Tree for the KYC registry, represented by the latest root hash known to the smart contract</li> </ul>"},{"location":"implementations/anon_nullifier_qurrency/","title":"Zeto_AnonNullifierQurrency","text":"Anonymity History Masking Encryption KYC Non-repudiation Gas Cost (estimate) - - 2,066,430 <p>This implementation builds on top of the <code>anon_nullifiers</code> to add post-quantum cryptography inside the circuit to encrypt sensitive information for a designated authority, such as a regulator, for auditing purposes.</p> <p>To implement post-quantum secure encryption, these circuits use the public key encryption scheme in ML-KEM (Module-Lattice-Based Key-Encapsulation Mechanism), which is derived from the CRYSTALS-KYBER algorithm. This algorithm has been selected by NIST for standardization of post-quantum secure encryption, meaning even quantum computers cannot break the cryptosystem.</p> <p>The encryption is performed in the follow step, according to the ML-KEM scheme:</p> <ul> <li>A 256-bit randomness is generated, and used as a private input to the ZKP circuit, which carries out the ML-KEM key encapsulation protocol along with the public key of the auditing authority<ul> <li>The public key is statically programmed into the circuit. This is to avoid making it a signal which would be very inefficient due to the large size of the public key (1184 bytes)</li> <li>IMPORTANT: This means for a real world deployment, the deployer MUST update the circuit with the auditing authority's public key and re-compile the circuit</li> </ul> </li> <li>The result of the ML-KEM protocol is a 256-bit shared secret<ul> <li>In addition, an encapsulated shared secret is also generated to be shared with the receiver (the auditing authority) to recover the shared secret</li> </ul> </li> <li>The secrets targeted for the auditing authority are encrypted with this shared secret, and sent as part of the transaction payload</li> <li>The ciphertext for the encrypted secrets, and the encapsulated shared secret for the ML-KEM decapsulation (the process to recover the shared secret) are returned by the circuit as output signals</li> <li>The auditing authority can then use their private key, along with the encapsulated shared secret which is included in the emitted blockchain event, to recover the shared secret via the ML-KEM decapsulation protocol<ul> <li>The recovered shared secret can then be used to decrypt the ciphertext of the encrypted secrets, giving the auditing authority full information about the secrets involved in the transaction</li> </ul> </li> </ul> <p>The statements in the proof include:</p> <ul> <li>each value in the output commitments must be a positive number in the range 0 ~ (2**100 - 1)</li> <li>the sum of the nullified values match the sum of output values</li> <li>the hashes in the output match the hash(value, salt, owner public key) formula</li> <li>the sender possesses the private BabyJubjub key, whose public key is part of the pre-image of the input commitment hashes, which match the corresponding nullifiers</li> <li>the nullifiers represent input commitments that are included in a Sparse Merkle Tree represented by the root hash</li> <li>the auditing authority's public key was correctly used in the ML-KEM encapsulation protocol, resulting in the ciphertext for decapsulation</li> <li>the shared secret, resulted from the above ML-KEM encapsulation protocol, was correctly used to encrypt the secrets in the transaction outputs</li> </ul> <p></p>"},{"location":"implementations/anon_nullifier_qurrency/#zero-knowledge-circuit-setup","title":"Zero-Knowledge Circuit Setup","text":"<p>In order to initialize a zero-knowledge proof circuit corresponding to a particular auditor, we require information about the auditor's ML-KEM public key to be encoded into the circuit.</p>"},{"location":"implementations/anon_nullifier_qurrency/#background","title":"Background","text":"<p>ML-KEM is a key-encapsulation mechanism, which internally initializes and uses a public key encryption scheme referred to as K-PKE. The Qurrency protocol uses this internal PKE scheme to provide post-quantum secure public key encryption. K-PKE was chosen because to date it is the only post-quantum secure PKE scheme to appear in a NIST standardization. It has been selected for standardization as a standalone post-quantum secure PKE scheme, and the standardization process is expected to complete by 2027.</p> <p>For any implementation, calling \\(\\mathsf{ML\\mathrm{-}KEM}.\\mathsf{KeyGen}()\\) will return an encapsulation key <code>ek</code> and a decapsulation key <code>dk</code>. Since <code>ek</code> is identical to the public key of the internal PKE scheme, we can directly use <code>ek</code> to build the ZK circuit. <code>ek</code> is an array of 800 bytes, of the following form:</p> <ul> <li>The first 768 bytes encode an array <code>t</code> of 512 integers modulo a prime \\(q\\), where \\(q = 3329\\). Each integer is encoded in 12 bits.</li> <li>The remaining 32 bytes is used as a random seed <code>rho</code>, which generates a matrix <code>a</code>. This is a 2x2 matrix, where each element is an array of 256 integers mod \\(q\\).</li> </ul> <p>Our circuits are designed for ML-KEM-512 in particular, so all parameters are chosen relative to this scheme.</p>"},{"location":"implementations/anon_nullifier_qurrency/#circuit-preparation","title":"Circuit Preparation","text":"<p>For this example, we'll demonstrate the circuit generation process using the <code>mlkem</code> npm module, although any secure ML-KEM implementation will suffice. After generating your keys:</p> <pre><code>const mlkem = new MlKem512();\nconst [ek, dk] = await mlkem.generateKeyPair();\n</code></pre> <p>Securely store <code>dk</code> to use in audits. (In particular, auditing requires the first 768 bytes of <code>dk</code>, which corresponds to the private key of the PKE scheme.) Then setup the <code>kyber.circom</code> circuit inside <code>zkp/circuits/lib/kyber</code> with the following steps.</p> <ol> <li>Separate <code>ek</code> into <code>t</code> (the first 768 bytes) and <code>rho</code> (the remaining 32 bytes).</li> <li>For each 384-byte half <code>ti</code> of <code>t</code>, compute <code>polyFromBytes(ti)</code>. This is the <code>mlkem</code> implementation of \\(\\mathsf{ByteDecode}_{12}\\) from the ML-KEM specification. It decodes the two halves of <code>t</code> back into arrays of integers. These two arrays can be inserted as <code>t[0]</code> and <code>t[1]</code> inside the <code>kyber_enc</code> circuit.</li> <li>Compute the matrix <code>a</code> as <code>_sampleMatrix(rho, false)</code>. In the ML-KEM specification, each entry <code>a[i,j]</code> of <code>a</code> is computed as \\(\\mathsf{SampleNTT}(\\rho \\mathbin\\Vert j \\mathbin\\Vert i)\\). In <code>mlkem</code>, this function computes all four entries of <code>a</code> at once. These can then be inserted into the corresponding <code>a[0][0]</code>, <code>a[0][1]</code>, <code>a[1][0]</code>, and <code>a[1][1]</code> inside the <code>kyber_enc</code> circuit.</li> </ol> <p>After this, circuit generation is complete, and setup can continue the same as all other Zeto tokens.</p> <p>Note: The <code>_sampleMatrix</code> function is not exposed by the <code>mlkem</code> library for external use, so for circuit initialization, you may have to either re-implement this functionality, or temporarily modify the library to expose this.</p>"},{"location":"implementations/anon_nullifier_qurrency/#utility-script","title":"Utility Script","text":"<p>A utility script has been provided in the <code>zkp/circuits/scripts</code> folder, which can be launched with the following command:</p> <pre><code>$ npm run qurrency-keygen\n</code></pre> <p>It prints out the following parts that are described above:</p> <ul> <li><code>t[0]</code></li> <li><code>t[1]</code></li> <li><code>a[0][0]</code></li> <li><code>a[0][1]</code></li> <li><code>a[1][0]</code></li> <li><code>a[1][1]</code></li> <li><code>PUBLIC KEY</code>: corresponding to the <code>ek</code> described above. This is not used directly because it's expanded format with <code>t</code> and <code>a</code> arrays will be added to the circuit directly to perform the encapsulation</li> <li><code>SECRET KEY</code>: corresponding to the <code>dk</code> described above. This should be used to decapsulate to recover the AES key from the cipher text.</li> <li><code>PUBLIC KEY HASH</code>: corresponding to the <code>signal sha3_256_digest[256]</code> in the template <code>g()</code> of the circuit <code>zkp/circuits/lib/kyber/mlkem.circom</code></li> </ul>"},{"location":"implementations/class_diagram/","title":"Contracts Class Diagram","text":""},{"location":"implementations/nf_anon/","title":"Zeto_NfAnon","text":"Anonymity History Masking Encryption KYC Non-repudiation Gas Cost (estimate) - - - - 271,890 <p>This implements a basic non-fungible token.</p> <p>For non-fungible tokens, the main concern with the transaction validity check is that the output UTXO contains the same secrets (id, uri) as the input UTXO, with only the ownership updated.</p> <p>The statements in the proof include:</p> <ul> <li>the output UTXO hashes are based on the same id, uri as the input UTXO hashes</li> <li>the sender possesses the private BabyJubjub key, whose public key is part of the pre-image of the input commitment hashes</li> </ul>"},{"location":"implementations/nf_anon_nullifier/","title":"Zeto_NfAnonNullifier","text":"Anonymity History Masking Encryption KYC Non-repudiation Gas Cost (estimate) - - - 1,450,258 <p>This implements a non-fungible token using nullifiers, thus hiding the spending graph.</p> <p>The statements in the proof include:</p> <ul> <li>the output UTXO hashes are based on the same id, uri as the input UTXO hashes</li> <li>the sender possesses the private BabyJubjub key, whose public key is part of the pre-image of the input commitment hashes, which match the corresponding nullifiers</li> <li>the nullifiers represent input commitments that are included in a Sparse Merkle Tree represented by the root hash</li> </ul>"}]}